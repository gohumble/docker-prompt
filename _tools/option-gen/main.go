package main

import (
	"errors"
	"flag"
	"fmt"
	prompt "github.com/c-bata/go-prompt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/k0kubun/pp"
)

var (
	output       string
	pkg          string
	variableName string
)

func convert() error {
	/*bytes := []byte(`
	Usage:  docker builder COMMAND

	Manage builds

	Commands:
	  build       Build an image from a Dockerfile
	  prune       Remove build cache

	`)*/
	bytes, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		return err
	}

	f, err := GetOptionsFromHelpText(string(bytes))
	if err != nil {
		return err
	}
	options := SplitOptions(f)
	suggests := ConvertToSuggestions(options)
	if output == "" {
		_, err = pp.Fprintln(os.Stdout, suggests)
	} else {
		f, err := os.Create(output)
		if err != nil {
			return err
		}
		defer f.Close()

		fmt.Fprintf(f, "// Code generated by 'option-gen'. DO NOT EDIT.\n\n")
		fmt.Fprintf(f, "package %s\n\n", pkg)
		fmt.Fprintln(f, `import (`)
		fmt.Fprintln(f, `prompt "github.com/c-bata/go-prompt"`)
		fmt.Fprintln(f, ")")
		fmt.Fprintln(f, "")
		fmt.Fprintf(f, "var %s = []prompt.Suggest{\n", strings.Title(variableName))
		for _, s := range suggests {
			fmt.Fprintf(f, "%#v,\n", s)
		}
		fmt.Fprintln(f, "}")
	}
	return err
}

func main() {
	flag.StringVar(&output, "o", "", "output file. print stdout if empty")
	flag.StringVar(&pkg, "pkg", "options", "package name")
	flag.StringVar(&variableName, "var", "flagXXX", "variable name")
	flag.Parse()

	if err := convert(); err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}
}

func GetOptionsFromHelpText(help string) (options string, err error) {
	x := strings.Split(help, "\nOptions:")
	if len(x) < 2 {
		x = strings.Split(help, "\nCommands:")
		if len(x) < 2 {
			return "", errors.New("parse error\n\n " + help)
		}
	}
	y := strings.Split(x[1], "\n\n")
	options = strings.Trim(y[0], "\n")
	return options, nil
}

func SplitOptions(options string) []string {
	lines := strings.Split(options, "\n")
	results := make([]string, 0, len(lines))
	var index int
	for _, l := range lines {
		if strings.HasPrefix(l, "  ") || index == 0 {
			results = append(results, strings.TrimSpace(l))
			index++
		} else {
			results[index-1] += " " + l
		}
	}
	return results
}

func convertToSuggest(x []string) []prompt.Suggest {
	key := x[0]
	description := x[1]

	var keys []string
	if strings.Contains(key, ", ") {
		keys = strings.Split(key, ", ")
	} else {
		keys = []string{key}
	}
	suggests := make([]prompt.Suggest, len(keys))
	for i := range keys {
		if strings.Contains(keys[i], "=") {
			keys[i] = strings.Split(keys[i], "=")[0]
		}
		keys[i] = strings.TrimSpace(keys[i])
		suggests[i] = prompt.Suggest{Text: keys[i], Description: strings.TrimLeft(description, " ")}
	}
	return suggests
}

func ConvertToSuggestions(options []string) []prompt.Suggest {
	suggestions := make([]prompt.Suggest, 0, len(options))
	for i := range options {
		x := strings.SplitN(options[i], "    ", 2)
		if len(x) > 1 {
			x := convertToSuggest(x)
			for j := range x {
				suggestions = append(suggestions, x[j])
			}
		}

	}
	return suggestions
}
